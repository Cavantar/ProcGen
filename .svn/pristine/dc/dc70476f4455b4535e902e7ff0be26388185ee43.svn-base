#include "Net.h"

Net::Net(glm::uvec2& dimensions, vector<glm::vec4>& vertices, GLSLShader& shader){
	prepareData(dimensions, vertices);
	copyToGfx(shader);
}

void Net::prepareData(glm::uvec2& dimensions, vector<glm::vec4>& vertices) {
	this->dimensions = dimensions;
	this->vertices = vertices;
	int rawDataSize = vertices.size() * 4 + vertices.size() * 3;

	// Pozycje i normalne
	rawData.resize(rawDataSize);
	memcpy(&rawData[0], &vertices[0], vertices.size() * sizeof(glm::vec4));

	// Indeksy Linii
	lineIndexVec = createGridLineIndex(dimensions.x, dimensions.y);
	numbOfLines = lineIndexVec.size();

	// Indeksy Trójk¹tów
	//cout << "Indexing Triangles \n";
	trianglesIndexVec = createGridTriangleIndex(dimensions.x, dimensions.y);
	numbOfTriangles = trianglesIndexVec.size();

    // cout << endl;

	// Lista s¹siedztwa
	if(!adjacencyLists.count(dimensions.x))
		adjacencyLists[dimensions.x] = createGridAdjacencyList(vertices, dimensions);

	//static unsigned int tempTime = glutGet(GLUT_ELAPSED_TIME);

	//Normalne 
	normals = getNormals(vertices, trianglesIndexVec, adjacencyLists[dimensions.x]);
	memcpy(&rawData[vertices.size() * 4], &normals[0], normals.size() * sizeof(glm::vec3));

	//cout << "Normals Took: " << glutGet(GLUT_ELAPSED_TIME) - tempTime << endl;
}
void Net::copyToGfx(GLSLShader& shader) {
	glGenBuffers(1, &lineIndexBuffer);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, lineIndexVec.size() * sizeof(glm::uvec2), &lineIndexVec[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	glGenBuffers(1, &triangleIndexBuffer);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, trianglesIndexVec.size() * sizeof(glm::uvec3), &trianglesIndexVec[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	glGenBuffers(1, &bufferObject);

	glBindBuffer(GL_ARRAY_BUFFER, bufferObject);
	glBufferData(GL_ARRAY_BUFFER, rawData.size() * 4, &rawData[0], GL_STREAM_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	// Tworzenie VAO

	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	glBindBuffer(GL_ARRAY_BUFFER, bufferObject);

	glEnableVertexAttribArray(shader["position"]);
	glVertexAttribPointer(shader["position"], 4, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(shader["normal"]);
	glVertexAttribPointer(shader["normal"], 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)(dimensions.x*dimensions.y * 4 * 4));
	glBindVertexArray(0);
	GL_CHECK_ERRORS;
}

void Net::render(RENDER_TYPE renderType) {
	glBindVertexArray(vao);

	switch(renderType) {
		case RT_POINTS:
			glDrawArrays(GL_POINTS, 0, dimensions.x * dimensions.y);
			break;
		case RT_LINES:
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
			glDrawElements(GL_LINES, numbOfLines * 2, GL_UNSIGNED_INT, 0);
			break;
		case RT_TRIANGLES:
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
			glDrawElements(GL_LINES, numbOfLines * 2, GL_UNSIGNED_INT, 0);

			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);
			glDrawElements(GL_TRIANGLES, numbOfTriangles * 3, GL_UNSIGNED_INT, 0);
			break;
	}
	glBindVertexArray(0);
}
glm::vec2 Net::getBounds(int dimension) {
	return getVec4Bounds(vertices, dimension);
}

map<int, vector<list<int>>> Net::adjacencyLists;