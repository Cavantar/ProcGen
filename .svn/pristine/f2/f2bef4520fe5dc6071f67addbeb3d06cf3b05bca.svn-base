#include "ChunkMap.h"
#include "Game.h"


void ChunkMap::process(GLSLShader& shader, glm::vec2& playerPosition) {

	if(didSettingsChange()) chunks.clear();

	list<glm::ivec2>& requiredChunks = getChunksForPosition(playerPosition);
	generateRequiredChunks(requiredChunks);
	deleteUnneededChunks(requiredChunks);
	checkChunks(shader);
	
	prevGenData = genData;
}

void ChunkMap::render(GLSLShader& shader, RENDER_TYPE renderType, GLuint globalMatricesUBO) {
	shader.use();
	for(auto i = chunks.begin(); i != chunks.end(); i++) {
		(*i)->render(shader, renderType, globalMatricesUBO);
	}
	shader.unUse();
}
void ChunkMap::setTweakBar(TwBar* bar) {

	TwAddVarRW(bar, "Frequency", TW_TYPE_FLOAT, &genData.noiseParams.frequency,
			   " label='Frequency' min=-0.1 max=100 step=0.1 keyIncr='+' keyDecr='-' help='Increase/decrease the frequency.' group='Noise Parameters'");
	TwAddVarRW(bar, "Octaves", TW_TYPE_INT32, &genData.noiseParams.octaves,
			   " label='Octaves' min=1 max=10 step=1 keyIncr='+' keyDecr='-' help='Increase/decrease number of octaves.' group='Noise Parameters'");
	TwAddVarRW(bar, "Lacunarity", TW_TYPE_FLOAT, &genData.noiseParams.lacunarity,
			   " label='Lacunarity' min=1.1 max=10.0 step=0.1 keyIncr='+' keyDecr='-' help='Increase/decrease the lacunarity.' group='Noise Parameters'");
	TwAddVarRW(bar, "Persistence", TW_TYPE_FLOAT, &genData.noiseParams.persistence,
			   " label='Persistence' min=0.1 max=1.0 step=0.1 keyIncr='+' keyDecr='-' help='Increase/decrease the persistence.' group='Noise Parameters'");
}
void ChunkMap::showDebugInfo() {
	cout << "Numb Of Chunks Rendered: " << chunks.size() << endl;
	cout << "Numb Of Chunks Preparing: " << preparingChunks.size() << endl;
	cout << "Numb Of Free Threads: " << threadsAvailable << endl;
}
void ChunkMap::checkChunks(GLSLShader& shader) {
	auto it = preparingChunks.begin();
	while(it!= preparingChunks.end()) {
		if((*it)->ready) {
			ChunkPtr chunkPtr = *it;
			chunkPtr->joinThreadAndCopy(shader);
			if(chunks.size() == 0) {
				shader.use();
				glUniform2fv(shader("heightBounds"), 1, &chunkPtr->heightBounds.x);
				shader.unUse();
			}
			chunks.push_back(chunkPtr);
			it = preparingChunks.erase(it);

			//cout << " Things Happened \n";
			// Thread Got Freed

			threadsAvailable++;
			// So there'll be one copyToGfx Per Frame
			//return ;
		}
		else it++;
	}
}
bool ChunkMap::didSettingsChange() {

	if(genData.noiseParams.frequency != prevGenData.noiseParams.frequency) return true;
	if(genData.noiseParams.octaves != prevGenData.noiseParams.octaves) return true;
	if(genData.noiseParams.lacunarity != prevGenData.noiseParams.lacunarity) return true;
	if(genData.noiseParams.persistence != prevGenData.noiseParams.persistence) return true;

	if(genData.noiseType != prevGenData.noiseType) return true;

	return false;
}
list<glm::ivec2> ChunkMap::getChunksForPosition(glm::vec2& position) {
	list<glm::ivec2> requiredChunks;

	glm::ivec2 normalizedPosition = glm::ivec2(((int)position.x) / 100, -((int)position.y) / 100);
	requiredChunks.push_back(normalizedPosition);
	//addSurrounding(normalizedPosition, requiredChunks);
	/*addFieldsInSquare(normalizedPosition, requiredChunks, 0);
	addFieldsInSquare(normalizedPosition, requiredChunks, 1);*/
	addFields(normalizedPosition, requiredChunks, 4);

	return requiredChunks;
}
void ChunkMap::generateRequiredChunks(list<glm::ivec2>& requiredChunks) {
	for(auto i = requiredChunks.begin(); i != requiredChunks.end(); i++) {
		if(!doesChunkExistsAtPosition(*i) && threadsAvailable > 0) {
			generateChunk(*i);
		}
	}
}
void ChunkMap::deleteUnneededChunks(list<glm::ivec2>& requiredChunks) {
	auto it = chunks.begin();
	while(it != chunks.end()) {
		bool shouldStay = false;
		glm::ivec2 position = glm::ivec2((*it)->position_x, (*it)->position_y);
		for(auto i = requiredChunks.begin(); i != requiredChunks.end(); i++) {
			if(*i == position) shouldStay = true;
		}
		if(!shouldStay) it = chunks.erase(it);
		else it++;
	}
}
bool ChunkMap::doesChunkExistsAtPosition(glm::ivec2& chunkPosition) {
	// Is It Done
	for(auto i = chunks.begin(); i != chunks.end(); i++) {
		if(glm::ivec2((*i)->position_x, (*i)->position_y) == chunkPosition) return true;
	}
	// Is It Preparing
	for(auto i = preparingChunks.begin(); i != preparingChunks.end(); i++) {
		if(glm::ivec2((*i)->position_x, (*i)->position_y) == chunkPosition) return true;
	}
	return false;
}

void ChunkMap::generateChunk(glm::ivec2& position) {
	//cout << "Generating Chunk !\n";
	ChunkPtr chunk = ChunkPtr(new Chunk());
	preparingChunks.push_back(chunk);
	chunk->startPrepareThread(position, genData);
	//cout << "position.x " << position.x << " position.y: " << position.y << endl;
	threadsAvailable--;
}
void ChunkMap::addSurrounding(glm::ivec2& position, list<glm::ivec2>& required) {
	required.push_back(position + glm::ivec2(1, 0));
	required.push_back(position + glm::ivec2(1, -1));
	required.push_back(position + glm::ivec2(0, -1));
	required.push_back(position + glm::ivec2(-1, -1));
	required.push_back(position + glm::ivec2(-1, 0));
	required.push_back(position + glm::ivec2(-1, 1));
	required.push_back(position + glm::ivec2(0, 1));
	required.push_back(position + glm::ivec2(1, 1));
}
void ChunkMap::addFields(glm::ivec2& position, list<glm::ivec2>& required, int radius) {
	for(int y = 0; y < radius; y++) {
		addFieldsInSquare(position, required, y);
	}
}
void ChunkMap::addFieldsInSquare(glm::ivec2& position, list<glm::ivec2>& required, int distance) {
	int squareLength = (distance + 1) * 2 + 1;
	
	for(int i = 0; i < squareLength; i++) {
		required.push_back(position + glm::ivec2(-distance - 1 + i, -distance - 1));
		required.push_back(position + glm::ivec2(-distance - 1 + i, distance + 1));
	}
	for(int i = 0; i < squareLength - 2; i++) {
		required.push_back(position + glm::ivec2(-distance - 1, -distance + i));
		required.push_back(position + glm::ivec2(distance + 1 , -distance + i));
		
	}
}