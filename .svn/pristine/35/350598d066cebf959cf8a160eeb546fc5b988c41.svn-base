#include "Chunk.h"
#include "Noise.h"


void Chunk::joinThreadAndCopy(GLSLShader& shader) {
	t.join();
	net.copyToGfx(shader);
	heightBounds = net.getBounds(2);
}
void Chunk::render(GLSLShader& shader, RENDER_TYPE renderType, GLuint globalMatricesUBO) {
	glBindBuffer(GL_UNIFORM_BUFFER, globalMatricesUBO);
	glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * 2, sizeof(glm::mat4), glm::value_ptr(glm::translate(glm::mat4(), glm::vec3(position_x * 100, 0, -position_y * 100))));
	glBindBuffer(GL_UNIFORM_BUFFER, 0);

	//glUniform2fv(shader("heightBounds"), 1, &heightBounds.x);
	
	net.render(renderType);
}
void Chunk::startPrepareThread(glm::ivec2& position, GenData& genData) {
	position_x = position.x;
	position_y = position.y;

	this->genData = genData;
	t = thread(&Chunk::prepare, this);
}
void Chunk::prepare() {
	//GL_CHECK_ERRORS
	float gridLength = 5.0f;

	int sideLength = 6;
	int sideLengthNorm = (int)pow(2, sideLength) + 1;
	glm::uvec2 dimensions = glm::uvec2(sideLengthNorm, sideLengthNorm);

	//static unsigned int tempTime = glutGet(GLUT_ELAPSED_TIME);
	//vector<glm::vec4> vertices = TerrainGenerator::generateTerrain(sideLength, glm::vec4(0.5f, 0.5f, 0.5f, 40.0f), gridLength);
	//ground->prepareData(dimensions, TerrainGenerator::generateTerrain(sideLength, glm::vec4(0.5f, 0.5f, 0.5f, 40.0f), gridLength));

	//NoiseParams noiseParams = { 0.75f, 5, 2.0f, 0.5f };
	if(genData.noiseType == NT_PERLIN) {
		//cout << genData.noiseParams.frequency << endl;
		net.prepareData(dimensions, Noise::getMap(glm::vec2(position_x, position_y), sideLengthNorm, genData.noiseParams));
	}
	

	//cout << "\n Time Taken To Generate: " << glutGet(GLUT_ELAPSED_TIME) - tempTime << endl;

	ready = true;
}
