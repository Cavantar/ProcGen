#version 330 core

in vec4 position;
in vec3 normal;

layout(std140) uniform GlobalMatrices
{
    mat4 cameraToClipMatrix;	// Perspective Matrix
    mat4 worldToCameraMatrix;	// CameraMatrix
	mat4 localToWorldMatrix;	// LocalMatrix

	unsigned int debugCounter;	// Counter
};

uniform vec4 colorSet[2];
uniform vec2 heightBounds;
smooth out vec4 smoothColor;

vec3 getLightDirection() {
	float timePassed = (debugCounter % 10000)/ 10000.0;
	float lightAngle = 3.14f * 2.0f * timePassed;
	float tiltAngle = 3.14f/3.0f;

	vec3 lightDirection = vec3(0, cos(tiltAngle), sin(tiltAngle));
	
	vec3 lightDirectionFinal;
	lightDirectionFinal.x = lightDirection.x * cos(lightAngle) - lightDirection.z * sin(lightAngle);
	lightDirectionFinal.y = lightDirection.y;
	lightDirectionFinal.z = lightDirection.x * sin(lightAngle) + lightDirection.z * cos(lightAngle);

	return lightDirectionFinal;
}

void main() {

	vec3 lightDirection = getLightDirection();

	// Light Calculations
	mat4 localToCamera = worldToCameraMatrix * localToWorldMatrix;
	mat3 localToCameraNormal = mat3(worldToCameraMatrix) * mat3(localToWorldMatrix);
	//vec4 tempNormal = localToCamera * vec4(normal, 0);

	// Incidence Angle
	lightDirection = localToCameraNormal * lightDirection;
	vec3 normCamSpace = normalize(localToCameraNormal * normal);
	float cosAngIncidence = dot(normCamSpace, lightDirection);
	cosAngIncidence = clamp(cosAngIncidence, 0, 1);

	float ambientLight = 0.2f;
	vec4 tempColor = vec4(1.0, 1.0, 1.0, 1.0);
	tempColor = vec4(normal, 1.0);

	// Color Interpolation

	float heightDelta = heightBounds.y - heightBounds.x;
	float heightPerc = (position.y - heightBounds.x)/heightDelta;

	//tempColor = mix(vec4(0,0.67,0,1.0), vec4(0,0,0.67,1.0), heightPerc);
	//oryg 
	tempColor = mix(colorSet[0], colorSet[1], heightPerc);
	//tempColor = mix(vec4(0,0.67,0,1.0), vec4(0.8,0.8,0.8,1.0), heightPerc);

	//smoothColor = tempColor;

	if(colorSet[1].z < 0.8f)smoothColor = tempColor * cosAngIncidence + tempColor * ambientLight; 
	else smoothColor = tempColor;
	gl_Position =   cameraToClipMatrix * localToCamera * position;
}
