#include "Game.h"
#include "TerrainGenerator.h"

void Game::setupAndStart() {
	srand(((unsigned int)time(NULL)));

	// Window Things 

	bool fullHD = true;
	glm::ivec2 mainWindowSize = fullHD ? glm::ivec2(1280, 720) : glm::ivec2(1000, 600);
	initializeWindow(mainWindowSize, "ProcGen");

	HWND consoleWindow = GetConsoleWindow();
	MoveWindow(consoleWindow, 0, mainWindowSize.y + 30, 1000, (fullHD ? 1080 : 720) - (mainWindowSize.y + 30), true);

	glutSetWindow(windowHandle);
	glutPopWindow();

	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);
	glFrontFace(GL_CW);

	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	glDepthFunc(GL_LEQUAL);
	glDepthRange(0.0f, 1.0f);


	perspectiveMatrix = glm::perspective(45.0f, (float)mainWindowSize.x / mainWindowSize.y, 1.0f, 1000.0f);

	setGlobalMatrices(); // Order Here is Very Important
	loadShaders();
	//initStuff();
	startThread();

	start();
}
void Game::myRenderFunction() {
	debugCounter += lastDelta;
	threadStuff();
	render();
	
	GL_CHECK_ERRORS
}

void Game::render() {

	static RENDER_TYPE renderType = RT_LINES;
	if(inputManager.isKeyPressed('1')) renderType = RT_POINTS;
	if(inputManager.isKeyPressed('2')) renderType = RT_LINES;
	if(inputManager.isKeyPressed('3')) renderType = RT_TRIANGLES;

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	
	static glm::mat4 modelViewMatrix;
	modelViewMatrix = *camera->update(inputManager, lastDelta);

	glBindBuffer(GL_UNIFORM_BUFFER, globalMatricesUBO);
	glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(modelViewMatrix));
	glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * 3, sizeof(unsigned int), &debugCounter);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);

	GL_CHECK_ERRORS
		if(shouldRender) {
			normalsShader.use();
			ground->render(renderType);
			normalsShader.unUse();
		}
	GL_CHECK_ERRORS

	glutSwapBuffers();
}

void Game::loadShaders() {
	shader.loadFromFile(GL_VERTEX_SHADER, "Shaders/shader.vert");
	shader.loadFromFile(GL_FRAGMENT_SHADER, "Shaders/shader.frag");
	shader.createAndLinkProgram();
	shader.use();
		shader.addAttribute("position");
		shader.addAttribute("color");
		shader.addUniform("MVP");
	shader.unUse();

	normalsShader.loadFromFile(GL_VERTEX_SHADER, "Shaders/normalsShader.vert");
	normalsShader.loadFromFile(GL_FRAGMENT_SHADER, "Shaders/normalsShader.frag");
	normalsShader.createAndLinkProgram();
	normalsShader.use();
		normalsShader.addUniformBlock("GlobalMatrices");
		normalsShader.addAttribute("position");
		normalsShader.addAttribute("normal");
		normalsShader.addUniform("heightBounds");
	normalsShader.unUse();

	//Binding UniformBlockIndex With Uniform Binding Index
	normalsShader.bindUniformBlock("GlobalMatrices", globalMatricesUBI);

}
void Game::setGlobalMatrices() {
	// Creating Buffers
	
	glGenBuffers(1, &globalMatricesUBO);
	glBindBuffer(GL_UNIFORM_BUFFER, globalMatricesUBO);
	// 3 4x4 matrices + float
	glBufferData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * 3 + sizeof(unsigned int), NULL, GL_STREAM_DRAW);

	// Setting Perspective Matrix Values (and temporarily local)
	glm::mat4 identity = glm::mat4(1);

	glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(perspectiveMatrix));
	glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * 2, sizeof(glm::mat4), glm::value_ptr(identity));

	// REMEMBER BINDING INDEX VALUE
	globalMatricesUBI = 0; // FUCKING HATE CONSTANTS LIKE THIS

	// Binding Buffer and Binding Index Value
	glBindBufferRange(GL_UNIFORM_BUFFER, globalMatricesUBI, globalMatricesUBO, 0, sizeof(glm::mat4) * 3);

	glBindBuffer(GL_UNIFORM_BUFFER, 0);
}
void Game::initStuff() {
	//GL_CHECK_ERRORS
	float gridLength = 5.0f;

	TerrainGenerator::sharpness = 200;
	int sideLength = 7;
	int sideLengthNorm = pow(2, sideLength) + 1;
	glm::uvec2 dimensions = glm::uvec2(sideLengthNorm, sideLengthNorm);
	

	static unsigned int tempTime = glutGet(GLUT_ELAPSED_TIME);
	//vector<glm::vec4> vertices = TerrainGenerator::generateTerrain(sideLength, glm::vec4(0.5f, 0.5f, 0.5f, 40.0f), gridLength);

	ground = shared_ptr<Net>(new Net());
	ground->prepareData(dimensions, TerrainGenerator::generateTerrain(sideLength, glm::vec4(0.5f, 0.5f, 0.5f, 40.0f), gridLength));

	cout << "\n Time Taken To Generate: " << glutGet(GLUT_ELAPSED_TIME) - tempTime << endl;


	//GL_CHECK_ERRORS

	done = true;
}
void Game::startThread() {
	t = thread(&Game::initStuff, this);
}
void Game::threadStuff() {
	if(done == true) {
		t.join();
		done = false;
		shouldRender = true;
		ground->copyToGfx(normalsShader);
		glm::vec2 heightBounds = ground->getBounds(2);
		normalsShader.use();
		glUniform2fv(normalsShader("heightBounds"),1,&heightBounds.x);
	}
}