#include "Net.h"


Net::Net(glm::uvec2& dimensions, vector<glm::vec4>& vertices, GLSLShader& shader) : dimensions(dimensions) {

	int rawDataSize = vertices.size() * 4 + vertices.size() * 3;

	// Pozycje i normalne
	rawData.resize(rawDataSize);

	memcpy(&rawData[0], &vertices[0], vertices.size() * sizeof(glm::vec4));

	// Indeksy Linii
	vector<glm::uvec2> lineIndexVec = createGridLineIndex(dimensions.x, dimensions.y);
	numbOfLines = lineIndexVec.size();

	glGenBuffers(1, &lineIndexBuffer);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, lineIndexVec.size() * sizeof(glm::uvec2), &lineIndexVec[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	// Indeksy Trójk¹tów
	cout << "Indexing Triangles \n";
	vector<glm::uvec3> triangles = createGridTriangleIndex(dimensions.x, dimensions.y);
	numbOfTriangles = triangles.size();

	glGenBuffers(1, &triangleIndexBuffer);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, triangles.size() * sizeof(glm::uvec3), &triangles[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	cout << endl;

	// Lista s¹siedztwa
	vector<list<int>> adjacencyList = createGridAdjacencyList(vertices, dimensions);

	static unsigned int tempTime = glutGet(GLUT_ELAPSED_TIME);

	//Normalne 
	vector<glm::vec3>& normals = getNormals(vertices, triangles, adjacencyList);
	memcpy(&rawData[vertices.size() * 4], &normals[0], normals.size() * sizeof(glm::vec3));

	cout << "Normals Took: " << glutGet(GLUT_ELAPSED_TIME) - tempTime << endl;

	// Kopiowanie do grafiki
	glGenBuffers(1, &bufferObject);

	glBindBuffer(GL_ARRAY_BUFFER, bufferObject);
	glBufferData(GL_ARRAY_BUFFER, rawDataSize * 4, &rawData[0], GL_STREAM_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);


	// Tworzenie VAO

	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	glBindBuffer(GL_ARRAY_BUFFER, bufferObject);

	glEnableVertexAttribArray(shader["position"]);
	glVertexAttribPointer(shader["position"], 4, GL_FLOAT, GL_FALSE, 0, 0);
	GL_CHECK_ERRORS
	glEnableVertexAttribArray(shader["normal"]);
	GL_CHECK_ERRORS
	glVertexAttribPointer(shader["normal"], 3, GL_FLOAT, GL_FALSE, 0, (GLvoid *)(vertices.size() * 4 * 4));
	GL_CHECK_ERRORS
	glBindVertexArray(0);
}

void Net::render(RENDER_TYPE renderType) {
	glBindVertexArray(vao);

	switch(renderType) {
		case RT_POINTS:
			glDrawArrays(GL_POINTS, 0, dimensions.x * dimensions.y);
			break;
		case RT_LINES:
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
			glDrawElements(GL_LINES, numbOfLines * 2, GL_UNSIGNED_INT, 0);
			break;
		case RT_TRIANGLES:
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineIndexBuffer);
			glDrawElements(GL_LINES, numbOfLines * 2, GL_UNSIGNED_INT, 0);

			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);
			glDrawElements(GL_TRIANGLES, numbOfTriangles * 3, GL_UNSIGNED_INT, 0);
			break;
	}
	glBindVertexArray(0);
}